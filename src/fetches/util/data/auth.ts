import { z } from "zod";


const login = z.string().min(1, { message: "Login is required." }).max(255, "Login is too long.");
const password = z.string().min(8, { message: "Password is too short." }).max(72, "Password is too long.");
const username = z.string().min(1, { message: "Username is required." }).max(255, "Username is too long.");


/** `registerFetch` request data schema. */
export const registerFetchData = z.object({
    login,
    password,
    password_repeat: z.string(),    //.min(8).max(71),
    username
}).refine(data => data.password === data.password_repeat, { path: ["password_repeat"], message: "Password must be repeated correctly." });


/** Schema of errors returned by `registerFetch`. */
export const registerFetchValidationErrors = z.object({
    errors: z.object({
        form: z.string().optional(),
        login: z.string().optional(),
        password: z.string().optional(),
        password_repeat: z.string().optional(),
        username: z.string().optional()
    }).optional()  
});


export type RegisterFetchValidationErrors = z.infer<typeof registerFetchValidationErrors>;


/** Processes parsing errors generated by `registerFetchData` into `registerFetchValidationErrors` schema. */
export const getRegisterFetchDataValidationErrors = (e: z.ZodError): RegisterFetchValidationErrors => {
    const errors = {} as any;
    for (let issue of e.issues) {
        const field = issue.path[0];
        errors[field] = issue.message;
    }
    return registerFetchValidationErrors.parse({ errors });
};
