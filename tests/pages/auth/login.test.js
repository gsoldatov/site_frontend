import React from "react";

import { getBackend, MockBackend } from "../../_mock-backend/mock-backend";
import { resetTestConfig } from "../../_mocks/config";
import { createTestStore } from "../../_util/create-test-store";
import { renderWithWrappers } from "../../_util/render";

import { AuthLoginActions } from "../../_ui/actions/pages/auth-login";

import { App } from "../../../src/components/app";

import { deepEqual } from "../../../src/util/equality-checks";
import { getAuthState } from "../../../src/types/store/data/auth";


/*
    /auth/login page tests.
*/
beforeEach(() => {
    // Set test app configuration
    resetTestConfig();
    
    global.backend = new MockBackend();
    global.fetch = global.backend.fetch;
});


test("Check validation error display", async () => {
    // Render login page
    const { store } = createTestStore({ addAdminToken: false });
    let { container } = renderWithWrappers(<App />, {
        route: "/auth/login", store
    });

    const authLoginActions = new AuthLoginActions(container);

    // Enter & submit form data with omitted login
    authLoginActions.enterCredentialsAndSubmit("", "password");
    await authLoginActions.waitForLoginError("Login is required.");
    
    // Enter & submit form data with a too long login
    authLoginActions.enterCredentialsAndSubmit("a".repeat(256), "password");
    authLoginActions.ensureNoErrors();      // Check if form field errors are cleared
    await authLoginActions.waitForLoginError("Login is too long.");

    // Enter & sumit form data with a too short password
    authLoginActions.enterCredentialsAndSubmit("login", "a".repeat(7));
    authLoginActions.ensureNoErrors();      // Check if form field errors are cleared
    await authLoginActions.waitForPasswordError("Password must be at least 8 characters long.");
    
    // Enter & submit form data with a too long password
    authLoginActions.enterCredentialsAndSubmit("login", "a".repeat(256));
    authLoginActions.ensureNoErrors();      // Check if form field errors are cleared
    await authLoginActions.waitForPasswordError("Password must be at most 72 characters long.");
});


test("Check fetch error display & form disabling during fetch", async () => {
    // Render login page
    const { store } = createTestStore({ addAdminToken: false });
    let { container } = renderWithWrappers(<App />, {
        route: "/auth/login", store
    });

    const authLoginActions = new AuthLoginActions(container);

    // Add a mock network error
    const backend = getBackend();
    backend.routeHandlers.auth.login.throwNetworkError = true;

    // Submit correct credentials
    authLoginActions.enterCredentialsAndSubmit("login", "password");

    // Check if form is disabled during fetch
    authLoginActions.ensureFormIsDisabled();

    // Wait for error message to appear
    await authLoginActions.waitForFormError("Failed to fetch data.");

    // Check if login form is enabled after fetch
    authLoginActions.ensureFormIsEnabled();
});


test("Correct login and form error reset", async () => {
    // Render login page
    const { store } = createTestStore({ addAdminToken: false });
    let { container, historyManager } = renderWithWrappers(<App />, {
        route: "/auth/login", store
    });

    // Check default auth state
    expect(deepEqual(store.getState().auth, getAuthState())).toBeTruthy();

    // Add a mock network error
    const backend = getBackend();
    backend.routeHandlers.auth.login.throwNetworkError = true;

    // Submit correct credentials & wait for error message to appear
    const authLoginActions = new AuthLoginActions(container);
    authLoginActions.enterCredentialsAndSubmit("login", "password");
    await authLoginActions.waitForFormError("Failed to fetch data.");

    // Remove mock network error and submit credentials again
    backend.routeHandlers.auth.login.throwNetworkError = false;
    authLoginActions.enterCredentialsAndSubmit("login", "password");

    // Check if form error was removed
    authLoginActions.ensureNoErrors();

    // Wait for redirect to index page and index page fetches to end
    await historyManager.waitForCurrentURLToBe("/");

    // Check if auth info was added to the state
    const authState = store.getState().auth;
    const expectedState = backend.data.generator.auth.login()["auth"];
    expect(authState.user_id).toEqual(expectedState.user_id);
    expect(authState.access_token).toEqual(expectedState.access_token);
    expect(authState.numeric_user_level).toEqual(20);   // admin user level
    expect(
        (new Date(expectedState.access_token_expiration_time)).getTime()
        - (new Date(authState.access_token_expiration_time)).getTime()
    ).toBeLessThan(1000);   // expiration time is (almost) the same, as generated by backend on the next call
});


test("Correct login with URL query params", async () => {
    // Render login page
    const params = new URLSearchParams();
    const redirectPath = "/objects/edit/1";
    params.append("from", redirectPath);
    const { store } = createTestStore({ addAdminToken: false });
    let { container, historyManager } = renderWithWrappers(<App />, {
        route: "/auth/login?" + params.toString(), store
    });

    // Check default auth state
    expect(deepEqual(store.getState().auth, getAuthState())).toBeTruthy();

    // Submit correct credentials
    const authLoginActions = new AuthLoginActions(container);
    authLoginActions.enterCredentialsAndSubmit("login", "password");

    // Wait for redirect to the specified page
    await historyManager.waitForCurrentURLToBe(redirectPath);

    // Check if auth info was added to the state
    const backend = getBackend();
    const authState = store.getState().auth;
    const expectedState = backend.data.generator.auth.login()["auth"];
    expect(authState.user_id).toEqual(expectedState.user_id);
    expect(authState.access_token).toEqual(expectedState.access_token);
    expect(authState.numeric_user_level).toEqual(20);   // admin user level
    expect(
        (new Date(expectedState.access_token_expiration_time)).getTime()
        - (new Date(authState.access_token_expiration_time)).getTime()
    ).toBeLessThan(1000);   // expiration time is (almost) the same, as generated by backend on the next call
});
